{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Doc%20Styling/","title":"Doc Styling","text":""},{"location":"Notes%20and%20References/","title":"Notes and References","text":""},{"location":"OpenBase%20Implementation/","title":"Database Implementation Overview","text":""},{"location":"OpenBase%20Implementation/#part-0-filesystem","title":"Part 0: Filesystem","text":""},{"location":"OpenBase%20Implementation/#part-1-record-management","title":"Part 1: Record Management","text":""},{"location":"OpenBase%20Implementation/#part-2-indexes","title":"Part 2: Indexes","text":""},{"location":"OpenBase%20Implementation/#part-3-system-management","title":"Part 3: System Management","text":""},{"location":"OpenBase%20Implementation/#part-4-query-language","title":"Part 4: Query Language","text":""},{"location":"OpenBase%20Implementation/#part-5","title":"Part 5: ??????????","text":""},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/","title":"Overview","text":"<p>The first step will be to build an interface that allows us to interface with files in our filesystem at the page granularity. We will use a reference implementation of C++ to guide us through this process. This provides a gentler introductionn to Go since we don't have to design this from scratch.</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/#pagedfile-interface","title":"PagedFile Interface","text":"<p>The three main parts of the filesystem interface we're building are the PagedFile Manager, the PagedFile handle, and the page handle. </p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/#pagedfile-manager","title":"PagedFile Manager","text":"<p>The PagedFile manager allows for typical lifecycle operations of creating, destroying, opening, and closing PagedFiles. The PagedFile manager can provide clients with PagedFile handles</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/#pagedfile-handles","title":"PagedFile handles","text":"<p>PagedFile handles can be used to allocate / deallocated file pages, search through pages, and do management modifications to pages like pinning and marking dirty.</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/#page-handles","title":"Page handles","text":"<p>Page handle provides access to the contents of a given page</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/#c-reference-code","title":"C++ Reference Code","text":"","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/#go-implementation","title":"Go Implementation","text":"","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/paged_file_interface/","title":"PagedFile Interface","text":"","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_handle_cpp_reference_code/","title":"C++ Reference Code for PagedFile Handle","text":"<p>This class is initiated and then unixfd is populated by passing a reference to this object to the manager Open function. The population of the unixfd file descriptor is what gives this class its functionality</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_handle_cpp_reference_code/#state","title":"State","text":"<ul> <li><code>PF_BufferMgr *pBufferMgr;                      // pointer to buffer manager</code></li> <li><code>PF_FileHdr hdr;                                // file header</code></li> <li><code>int bFileOpen;                                 // file open flag</code></li> <li><code>int bHdrChanged;                               // dirty flag for file hdr</code></li> <li><code>int unixfd;                                    // OS file descriptor</code></li> </ul>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_handle_cpp_reference_code/#functions","title":"Functions","text":"<p>The most important functionality of the PagedFile handle is the ability to allocate pages, get pages based on page number, and dispose pages.</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_handle_cpp_reference_code/#allocate-page","title":"Allocate Page","text":"<pre><code>// AllocatePage\n//\n// Desc: Allocate a new page in the file (may get a page which was\n//       previously disposed)\n//       The file handle must refer to an open file\n// Out:  pageHandle - becomes a handle to the newly-allocated page\n//                    this function modifies local var's in pageHandle\n// Ret:  PF return code\n//\nRC PF_FileHandle::AllocatePage(PF_PageHandle &amp;pageHandle)\n{\n   int     rc;               // return code\n   int     pageNum;          // new-page number\n   char    *pPageBuf;        // address of page in buffer pool\n\n   // File must be open\n   if (!bFileOpen)\n      return (PF_CLOSEDFILE);\n\n   // If the free list isn't empty...\n   if (hdr.firstFree != PF_PAGE_LIST_END) {\n      pageNum = hdr.firstFree;\n\n      // Get the first free page into the buffer\n      if ((rc = pBufferMgr-&gt;GetPage(unixfd,\n            pageNum,\n            &amp;pPageBuf)))\n         return (rc);\n\n      // Set the first free page to the next page on the free list\n      hdr.firstFree = ((PF_PageHdr*)pPageBuf)-&gt;nextFree;\n   }\n   else {\n\n      // The free list is empty...\n      pageNum = hdr.numPages;\n\n      // Allocate a new page in the file\n      if ((rc = pBufferMgr-&gt;AllocatePage(unixfd,\n            pageNum,\n            &amp;pPageBuf)))\n         return (rc);\n\n      // Increment the number of pages for this file\n      hdr.numPages++;\n   }\n\n   // Mark the header as changed\n   bHdrChanged = TRUE;\n\n   // Mark this page as used\n   ((PF_PageHdr *)pPageBuf)-&gt;nextFree = PF_PAGE_USED;\n\n   // Zero out the page data\n   memset(pPageBuf + sizeof(PF_PageHdr), 0, PF_PAGE_SIZE);\n\n   // Mark the page dirty because we changed the next pointer\n   if ((rc = MarkDirty(pageNum)))\n      return (rc);\n\n   // Set the pageHandle local variables\n   pageHandle.pageNum = pageNum;\n   pageHandle.pPageData = pPageBuf + sizeof(PF_PageHdr);\n\n   // Return ok\n   return (0);\n}\n</code></pre>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_manager_cpp_reference_code/","title":"C++ Reference Code for PagedFile Manager","text":"","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_manager_cpp_reference_code/#state","title":"State","text":"<p>This class stores no state</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_manager_cpp_reference_code/#functions","title":"Functions","text":"<p>The most important functionnality of the PagedFile manager is creating and opening files.</p>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_manager_cpp_reference_code/#creating-a-pagedfile","title":"Creating a PagedFile","text":"<pre><code>// Desc: Create a new PF file named fileName\n// In:   fileName - name of file to create\n// Ret:  PF return code\n//\nRC PF_Manager::CreateFile (const char *fileName)\n{\n   int fd;      // unix file descriptor\n   int numBytes;        // return code form write syscall\n\n   // Create file for exclusive use (1)\n   if ((fd = open(fileName, // (2)!\n#ifdef PC\n         O_BINARY |\n#endif\n         O_CREAT | O_EXCL | O_WRONLY,\n         CREATION_MASK)) &lt; 0)\n      return (PF_UNIX);\n\n   // Initialize the file header: must reserve FileHdrSize bytes in memory\n   // though the actual size of FileHdr is smaller\n   char hdrBuf[PF_FILE_HDR_SIZE];\n\n   // So that Purify doesn't complain\n   memset(hdrBuf, 0, PF_FILE_HDR_SIZE);\n\n   PF_FileHdr *hdr = (PF_FileHdr*)hdrBuf;\n   hdr-&gt;firstFree = PF_PAGE_LIST_END;\n   hdr-&gt;numPages = 0;\n\n   // Write header to file\n   if((numBytes = write(fd, hdrBuf, PF_FILE_HDR_SIZE))\n         != PF_FILE_HDR_SIZE) {\n\n      // Error while writing: close and remove file\n      close(fd);\n      unlink(fileName);\n\n      // Return an error\n      if(numBytes &lt; 0)\n         return (PF_UNIX);\n      else\n         return (PF_HDRWRITE);\n   }\n\n   // Close file\n   if(close(fd) &lt; 0)\n      return (PF_UNIX);\n\n   // Return ok\n   return (0);\n}\n</code></pre> <ol> <li>the <code>open</code> syscall is capable of opening files or creating them if they do not yet exist</li> <li>assignments are expressions in C++. The value of the expression is the value stored in the left operand after the assignment has taken place</li> </ol>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/pf_manager_cpp_reference_code/#opening-a-pagedfile","title":"Opening a PagedFile","text":"<p>A client has a PF_Manager object. The client creates a PF_FileHandle object. The client calls PF_Manager::OpenFile and passes along a reference to their  FileHandle object. After this function completes, if successful, the FileHandle object will now have an initialized fileDescriptor. <pre><code>// Desc: Open the paged file whose name is \"fileName\".  It is possible to open\n//       a file more than once, however, it will be treated as 2 separate files\n//       (different file descriptors; different buffers).  Thus, opening a file\n//       more than once for writing may corrupt the file, and can, in certain\n//       circumstances, crash the PF layer. Note that even if only one instance\n//       of a file is for writing, problems may occur because some writes may\n//       not be seen by a reader of another instance of the file.\n// In:   fileName - name of file to open\n// Out:  fileHandle - refer to the open file\n//                    this function modifies local var's in fileHandle\n//       to point to the file data in the file table, and to point to the\n//       buffer manager object\n// Ret:  PF_FILEOPEN or other PF return code\n//\nRC PF_Manager::OpenFile (const char *fileName, PF_FileHandle &amp;fileHandle) {\n    // return code\n   int rc; // (1)!\n\n   // Ensure file is not already open\n   if (fileHandle.bFileOpen)\n      return (PF_FILEOPEN);\n\n   // Open the file\n   if ((fileHandle.unixfd = open(fileName, // (2)!\n#ifdef PC\n         O_BINARY | \n#endif\n         O_RDWR)) &lt; 0)\n      return (PF_UNIX);\n\n   // Read the file header\n   {\n      int numBytes = read(fileHandle.unixfd, (char *)&amp;fileHandle.hdr,\n            sizeof(PF_FileHdr));\n      if (numBytes != sizeof(PF_FileHdr)) {\n         rc = (numBytes &lt; 0) ? PF_UNIX : PF_HDRREAD;\n         goto err; // (3)!\n      }\n   }\n\n   // Set file header to be not changed\n   fileHandle.bHdrChanged = FALSE;\n\n   // Set local variables in file handle object to refer to open file\n   fileHandle.pBufferMgr = pBufferMgr;\n   fileHandle.bFileOpen = TRUE;\n\n   // Return ok\n   return 0;\n\nerr:\n   // Close file\n   close(fileHandle.unixfd);\n   fileHandle.bFileOpen = FALSE;\n\n   // Return error\n   return (rc);\n}\n</code></pre></p> <ol> <li>return code</li> <li>assignments are expressions in C++. The value of the expression is the value stored in the left operand after the assignment has taken place</li> <li>the goto statement transfers control to the location specified by label</li> </ol>","tags":["part-0-filesystem"]},{"location":"OpenBase%20Implementation/Part%200%20Filesystem/useful_resources/","title":"Useful Resources","text":"<ul> <li><code>man 2</code> to get man page documentation for system calls, C++ intefaces with the syscall interface via <code>&lt;unistd.h&gt;</code></li> </ul>","tags":["part-0-filesystem"]},{"location":"Project%20Sources/","title":"Project Resources","text":"<p>The many things I took inspiration from to build this project.</p>"},{"location":"Project%20Sources/books/","title":"Books","text":""},{"location":"Project%20Sources/courses/","title":"Courses","text":"<ul> <li>http://users.cms.caltech.edu/~donnie/dbcourse/lectures/DBProjLec1.pdf</li> <li>https://web.stanford.edu/class/cs346/2015/</li> </ul>"},{"location":"Project%20Sources/source_repos/","title":"Source Repos","text":"<ul> <li>https://github.com/haowei01/redbase/tree/master</li> </ul>"},{"location":"","title":"Welcome to OpenBase","text":""},{"location":"#part-0-filesystem","title":"part-0-filesystem","text":"<ul> <li>Overview</li> <li>PagedFile Interface</li> <li>C++ Reference Code for PagedFile Handle</li> <li>C++ Reference Code for PagedFile Manager</li> <li>Useful Resources</li> </ul>"}]}